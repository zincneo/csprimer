#include <iostream>

int main() {
    // 右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值
    int i = 0;
    // int &&rref_i = i; 报错，不能将左值绑定到右值引用上
    int &&rref_i = std::move(i); // move函数让编译器忽略左值的地址属性，注意是整体是一个右值，i还是一个左值
    i = 100; // 但是不应该再使用i
    // move函数让操作的对象失去了地址属性，所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性
    // 这里先死记硬背，意义在cpp面向对象当中才能体现出来

    // 右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象
    // 程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性
    int &&rref_I = getI(); // 函数返回值是最典型的临时对象
    return 0;
}

int getI() {
    return 10;
}