#include <iostream>

int main()
{
    // const关键字可以在编译的时候让编译器将变量当作常量对待，但是在运行期和正常的变量一样都是在栈上或者堆上，和真正的常量有本质区别
    const int n = 50;
    // auto关键字可以让编译器自动推断出来
    // 但是前提是知道编译器会推导出来什么类型，否则可能导致莫名其妙的问题
    // 1.auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号
    // 2.auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象
    // 3.auto关键字在推断类型时，如果没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针
    // 4.auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留
    // 5.可以在前面加上const，这样永远都有const的含义
    const int i = 0;
    const int* const pi = &i;
    auto pi2 = pi; // auto自动推断出来的类型是const int *，保留了修饰指针的const，丢失了修饰值的const
    auto i1 = i; // auto自动推断出来的类型是int，丢失了修饰值的const
    auto &i2 = i; // auto自动推断出来的类型是const int，加上了引用之后就保留值的const
    // 之所以出现3，4的原因就是值传递的时候修改不会影响原来的值因此丢失const是无所谓的，但是指针传递丢失const会导致原来的值被修改
    // 6.auto不会影响编译速度，甚至会加快编译速度。
    // 7.重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先
    // 8.auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题
    return 0;
}
